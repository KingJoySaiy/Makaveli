## 一、基础

### 1.1 图论基本概念
* **邻接矩阵**：用n*n的二维数组记录每对点之间的权值或是否有边；**邻接表**：用二维链表记录从每个点出发能到达的结点。
* **顶点的度**：与顶点关联的边/弧的数目。特别的，在有向图中有 **出度**（以v作为终点的弧的数目）和 **入度**（以v作为起点的弧的数目）之分。
* **完全图**：任意2顶点之间都 **相邻**（有边相连）的图。**无向完全图** 边数为`n(n-1)/2`；**有向完全图**的边数为`n(n-1)`。
* **路径**：顶点序列$v_i,v_j...v_k$，满足相邻顶点之间有边 ；**路径长度**：路径上边的长度。
* **简单路径**：路径中不存在重复的顶点；若存在重复的点则称为 **复杂路径**。
* **环/回路**：路径中第一个顶点和最后一个顶点相同。
* **连通性**：无向图中，若2顶点之间有路径，则称该2个顶点是连通的；**连通图**：若无向图中任意2顶点都是连通的，则称该图为连通图。**连通分量**：无向图中的极大连通子图。
* **强连通图**：有向图的任意2顶点之间都有路径，则称为该有向图为强连通图；**强连通分量**：有向强连通图的极大子图。（满足任意2点都连通的条件时，无向图 **弱连通**，有向图 **强连通**）

### 1.2 并查集
* **问题提出**：要求快速查询2个元素是否属于同一组；快速合并2元素所在的组。
* **基本思想**：每个元素看作是单独的一棵树，则 **合并** 可以理解为将2棵树合并为一棵树的过程，**查询** 可以理解为查询2结点是否有同一个根节点。注意要避免出现类似于构造二叉搜索树时那种 **退化** 现象，其后果是查询复杂度大大增加。
* **具体实现**：为避免 **退化** 发生，对于每棵树，记录这棵树的高度rank；在合并2棵树时，rank小的树向大的树合并。`fa[maxn]`记录每个结点的父节点，`rank[maxn]`记录树的高度，初始状态`fa[i] = i, rank[i] = 1`；查询时用不断递归调用`fa[x] = find(fa[x])`，直到找到满足`fa[x] = x`条件的根节点，从而在查询时更新每个结点的父节点，降低之后的查询深度。
* [并查集代码实现](https://github.com/KingJoySaiy/Iterator/blob/master/Fundamental/UnionFind.h)

## 二、文件

### 2.1 FILE文件指针

* **文件和流**：C语言中文件作为字节流处理，文件结束位置有`文件结束符EOF`（即宏定义-1）。执行程序时系统先自动建立3个文件流：`标准输入流stdin`、`标准输出流stdout`和`标准错误流stderr`，分别用来从键盘读取数据、在屏幕上输出数据和处理错误，这3种都是`stdio.h`中的`File`结构体指针类型（视键盘、屏幕和错误为文件）。
* **FILE结构体**：FILE用于文件操作，不必了解该结构的细节，只用知道FILE是间接的操作系统的`文件控制快FCB`来实现对文件的操作的。以下是一些常用方法：
* `int feof(FILE *fp)`判断文件指针是否已经到文件末尾。
* `int ferror(FILE *fp)`用于在调用何种输入输出方法（fputc, fgetc, fread, fwrite等）后，判断该文件指针是否有出错情况。
* `void clearerr(FILE *fp)`清除可能影响前两者结果的`文件结束标志`和`出错标志`。
* `long ftell(FILE *fp)`获取fp相对于文件开头位置的偏移量，异常返回EOF；
* `void rewind(FILE *fp)`fp重新指向文件开头位置。
* `int fseek(FILE *fp, long offset, int base)`fp移到相对于base的offset处，正常返回当前指针位置，异常返回EOF。

### 2.2 文件打开与关闭

* **打开文件**：`FILE* fopen(char *fname, char *fmode)`，返回文件指针，不成功则NULL。常见文件打开方式有：`"r"只读、"W"只写、"a"追加、"rb/wb/ab"打开二进制文件`；在后加上`"+"`则清空原内容并打开新的空白文件（若不存在原文件，"w"建立新文件，"r"和"a"则出错）
* **关闭文件**：`int fclose(FILE *fp)`关闭文件指针，正常关闭返回0，异常则返回EOF。
```c++
//	FILE *p = fopen("C:\\KingJoy\\workspace\\test", "w");	//absolute path
	FILE *p = fopen("test", "r");	//relative path
	if (p != NULL) {
		cout << "successful open!" << endl;
	}
	fclose(p);
```

### 2.3 读写文件
* **读写一个字符**：`int fgetc(FILE *fp)`用于从fp中读取一个字符并返回ASCII码，异常返回EOF；`int fputc(int c, FILE *fp)`将ASCII码为c的字符写入fp，正常返回c，异常返回EOF。一个复制文件的应用如下：
```c++
	//copy "data.txt" to "test.txt"
	FILE *in = fopen("data.txt", "r");
	FILE *out = fopen("test.txt", "w");
	if (in == NULL or out == NULL) {
		cout << "fail to open!" << endl;
		return 0;
	}
	/**** start copy ****/
	char c;
	while ((c = fgetc(in)) != EOF) {	//get char
		fputc(c, out);	//put char
	}
	/**** end copy ****/
	fclose(in);
	fclose(out);
```

* **读写一个字符串**：`char* fgets(char *str, int n, FILE *fp)`从fp中读取n-1个字符，写入str中（末尾加'\0'），正常返回str，异常返回NULL；`int fputs(char *str, FILE *fp)`将字符串str写入fp，正常返回非负数，异常返回EOF。上例的另一种实现如下：
```c++
	char s[100];
	while(fgets(s, 100, in)) {
		if (fputs(s, out) == EOF) {
			cout << "fail to write" << endl;
		}
	}
```

* **格式化读写**：`int fprintf(FILE *fp, char *format, argList)`格式化写入fp文件，正常返回参数个数，异常返回EOF；`int fscanf(FILE *fp, char *format, argList)`格式化读取fp内容到argList，正常返回参数个数，异常返回EOF。一种应用如下，需注意的是`fscanf`一般情况下不会读取`tab / space / enter`等字符，而是将其作为分隔符放在输入缓存中。
```c++
	while(fscanf(in, "%s", s) != EOF) {
 		if (fprintf(out, "%s", s) == EOF) {
			cout << "fail to write!" << endl;
		}
	}
```

* **二进制读写**：`size_t fread(void *buffer, size_t size, size_t n, FILE *fp)`将fp文件读取到buffer中，size指定字节大小，n指定size的个数，正常返回n，异常返回[0, n)之间的值；`size_t fwrite(const void *buffer, size_t size, size_t n, FILE *fp)`将buffer内容写入fp中，size、n含义及返回值同上。实现如下：
```c++
	const int n = 4;
	char s[n];
	while (fread(s, sizeof(char), n, in) == n) {	
		if (fwrite(s, sizeof(char), n, out) != n) {
			cout << "fail to write!" << endl;
		}
	}
```

## 三、线性表, 栈, 队列, 数组

### 3.1 线性表

* 线性表有 **顺序实现** 和 **链式实现**（起始地址*base, 当前长度len，总长度size） ，链式分为 **单链表**（分为带头结点和不带头结点）、**循环单链表**（head->next=null则空表，须有头指针或尾指针，无头结点）、**双向链表**（有头结点）。
* **链表头结点** ：不带头结点是指head是直接指向首结点的指针，即`head->data`为首结点数据；带头结点是指头结点为多余的新结点，其数据域无意义，指针域指向首结点，即`head->next->data`为首结点数据。单链表带头结点的好处是可以在表头插入结点。
* [List代码实现](https://github.com/KingJoySaiy/Iterator/blob/master/Data%20Structure/List.h)

### 3.3 栈和队列

* **顺序栈**（起始地址* base，栈顶* top，总长度size）；**链栈**（带头结点的单链表，头插法）。
* [Stack代码实现](https://github.com/KingJoySaiy/Iterator/blob/master/Data%20Structure/Stack.h)
* **链队列**（结点QNode[data, *next]，队列Queue[QNode front, rear]）；**顺序循环队列**（ * base，front，rear），注意取模，(rear+1)%maxsize==front则满。
* [Queue代码实现](https://github.com/KingJoySaiy/Iterator/blob/master/Data%20Structure/Queue.h)

### 3.4 数组

* 数组一旦确定了维数和每一维的元素个数，就确定了整个数组元素个数，故只需用顺序实现即可。其顺序存储结构有：以行为主序和以列为主序，在此只讨论以行序为主序。

以二维数组为例，\*base为基址，\*bounds为每一维元素个数（从1开始），L为每个数据元素所占存储单元，则有 $(i,j)=base+(bounds_i×i+j)L$ 。例如3 * 4的二维矩阵中(1,2)相对于基址base的偏移量为 $4*1+2=6$。

* 推广到n维，有$(j_1,j_2...j_n)=a+[\sum_{i=1}^{n-1}(j_i\prod_{k=i+1}^nb_k)]L$ ，可设constants（$c_n=L, c_{i-1}=b_i×c_i$）从而有 $(j_1,j_2...j_n)=a+L\sum_{i=1}^nc_i$ 。从而有：（基址 \*base, 维数dim, 每一维元素个数 \*bounds，各维数+1时相对基址移动距离 \*constants。

* [Array代码实现](https://github.com/KingJoySaiy/Iterator/blob/master/Data%20Structure/Array.h)

* **矩阵压缩**：对称矩阵、三角矩阵、对角矩阵算一算下标存到顺序表即可；稀疏矩阵用（i, j, data）存到顺序表（truple *base, 行数n, 列数m, 非0元素个数count）中。

## 四、 树和二叉树

### 4.1 树和二叉树

* **非空树**：有且仅有1个根结点，其余结点可分为若干个有限集，每个集合本身又是一棵树（称为子树）。**结点的度**：结点有的子结点个数。**叶子 / 终端结点**：度为0的终端结点（**非终端结点 / 分支结点**反之）。**层次**：根为第1层，根的孩子为第2层，以此类推。**深度 / 高度**：树中结点的最大层次（空树层次为0）。**兄弟结点**：有同一个双亲的结点。**堂兄弟结点**：各自双亲在同一层的结点。**祖先**：从该结点到根所经分支上的所有结点（不含本身，**子孙**即子树中所有结点）。**有序树**：树中结点的各个子树从左到右有序的（**无序树**反之）。**森林**：若干棵不相交的树的集合。
* **二叉树**：度不大于2的有序树。**满二叉树**：深度为k（k≥0）且含有 $2^k-1$ 个结点的二叉树。**完全二叉树**：编号1-n按照满二叉树的结点位置，从根结点起，从上往下从左到右编排（满二叉树是完全二叉树）。
* **二叉树分支数 = 结点数 - 1** ； **度为2的结点数=叶子结点数-1**。
* 有n个结点的完全二叉树深度为 $⌊log_2n⌋-1$ 。
* 完全二叉树**顺序存储**：基址 * base，算一算下标存进去。 **链式存储**：（data, 双亲指针 * parent, 左子节点 * lchild, 右子节点*rchild），parent可以去掉。**双亲表示法**：node（data，双亲位置parent），tree（起始地址 * base，根位置root，结点数n）。**孩子表示法**：list（位置id， * next），node（data，孩子链表 list * children），tree（ * base, root, n）。**二叉链表表示法** ：node（data, 第1个子节点 * firstChild，下一个兄弟结点 * nextSibling），即二维的链表，行即为层数，列即为每行兄弟结点序列。

（二叉树代码实现，占坑）

### 4.2 遍历二叉树、树和森林

* **遍历二叉树**：先序遍历（根左右）；中序遍历（左根右）；后序遍历（左右根）。
* **线索二叉树**（data 左指针 * lchild, 右指针 * rchild，左标记ltag，右标记rtag）的构造：左指针优先指向左子树，若该结点无左子树则指向前驱结点（右指针同理）；标记0表示指向左子结点，为1表示指向前驱结点；头结点左指针指向根结点，右指针指向遍历的最后结点；遍历的第一个结点左指针和最后一个结点右指针，都指向指向头结点。

（递归与非递归遍历二叉树，线索化代码，占坑）

* **森林转化为二叉树** ：若森林空，则二叉树空；否则森林的第一棵树的根作为二叉树的根，第一棵树的子森林转化为二叉树根的左子树，森林除第一棵外的的其余树转化为二叉树根的右子树，依次递归。（特别的，当只有一棵树，转化后的二叉树的根没有右子树；**树也是森林**）。
* **二叉树转化为森林** ：若为空二叉树，则森林空；否则二叉树的根作为森林的第一棵树的根，其左子树转化为森林第一棵树的子森林，右子树转化为森林的其余树，依次递归。

（森林与二叉树的转化代码，占坑）

* **树的遍历**：先根遍历；后根遍历。
* **森林的遍历**：先序遍历（访问第一棵树的根、先序遍历第一棵树的子树森林、先序遍历除第一棵树外的森林）；中序遍历（中序遍历第一棵树的子树森林、访问第一棵树的根、中序遍历除第一棵树外的森林）。
* 注意遍历方式的不同：**二叉树（先序、中序、后序）**；**树（先根、后根）**；**森林（先序、中序）**！

### 4.3 Huffman树

* 树中从一个结点到另一个结点之间的分支构成2结点之间的路径，路径上的分支数目称为 **路径长度**。**树的路径长度** 是从树根到每个结点的路径长度之和。
* 树中所有叶子结点的带权路径长度之和，称为 **树的带权路径长度**，记为$WPL=\sum_{k=1}^nw_kl_k$，$w_k$为每个结点的权值，$l_k$为每个结点的路径长度。WPL最小的二叉树称为 **最优二叉树** 或 **哈夫曼树**。
* **构造Huffman树**：给定n个只含根节点的二叉树，按根节点权值升序；每次取出权值最小的2个二叉树，合并为新的二叉树，新树的根节点权值为二者权值之和；依次类推。
* **Huffman编码**：用二叉树对字符设计二进制的 **前缀编码**（每个字符的编码都不是另一个的前缀），从根节点到叶子节点的分支作为该叶子节点字符的编码（**左0右1**）。$w_k$为每个字符在电文中的出现次数，$l_k$为该字符的编码的长度，则电文总长（带权路径长度） $WPL=\sum_{k=1}^nw_kl_k$最小时，该编码方式称为Huffman编码。
* [Huffman编码c++简单实现](https://github.com/KingJoySaiy/Iterator/blob/master/Data%20Structure/HuffmanCoding.cpp)

## 五、查找,递归与分治

### 5.1 动态查找

* **二叉搜索树 / 排序树 / 查找树**：左子树所有节点值都小于根节点值，右子树所有节点值都大于根节点值。
* **平衡二叉树 / AVL树**：左右子树都是平衡二叉树，左右子树深度只差不超过1。**平衡因子**：左子树深度减右子树深度（只可能为-1,0,1）。
*  **平衡处理**：为防止构造二叉搜索树时因插入顺序使之蜕变为单支树，保证其一直为平衡二叉树。**LL右旋平衡处理**如下：

<img src="_image/1.png" style="zoom:30%;" />

**RR左旋平衡处理**如下：

<img src="_image/2.png" style="zoom:32%;" />

LL和RR为两种**单向旋转平衡处理**，此外还有**LR先左后右**和**RL先右后左**2种**双向旋转平衡处理**。

### 5.2 B树

（占坑）

### 5.3 哈希表

* **哈希函数**：记录的关键字到存储位置的一种映射关系。**哈希冲突**：不同关键字可能得到同一哈希地址，称之为**同义词**，这种现象称为哈希冲突。**哈希表 / 散列表**：根据设定的哈希函数和处理冲突的方法，将一组关键字映射到一个有限的连续的地址集（区间）上的表。
* **哈希函数的构造法**：①**直接定址**：取关键字的线性函数值为哈希地址，即`hash(key) = a*key + b`；②**除留余数法**：将关键字取模后的结果作为哈希地址，即`hash(key)=key MOD p`，(p≤哈希表长），一般情况下p取质数或不包含小于20的质因数的合数；③**随机数法**：取关键字的随机函数值作为哈希地址，即`hash(key) = random(key)`，适用于关键字长度不等的情况。
* **哈希冲突处理方法**：①**开放地址法**：遇到哈希冲突时继续探测，直到无冲突为止，$hash_i=(hash(key)+d_i)MOD m,（1≤i<m）$，$d_i=1,2,3...m-1$称为 **线性探测**，$d_i=1^2,-1^2,2^2,-2^2,3^2...$称为**二次探测**，$d_i=$伪随机数称为**伪随机探测**；②**再哈希法**：$hash_i=ReHash_i(key)$，即遇到哈希冲突时计算另一个哈希函数地址，直到冲突不再发生；③**链地址法**：将所有同义关键字的记录存到同一线性链表中， 从而避免哈希冲突。④**建立公共溢出区**：除哈希表Hashtable[0...m-1]外，另设溢出表OverTable[0...v]存放发生了哈希冲突的记录。

（哈希表代码实现，占坑）

### 5.4 分治策略

* **大整数乘法**：设XY都是n位二进制整数（n偶），分别把XY拆为2半$X=A2^{\frac{n}{2}} + B, Y=C2^{\frac{n}{2}}+D$，从而有$XY=AC2^n+[(A-B)(D-C)+AC+BD]2^{\frac{n}{2}}+BD$，从而只要算`AC,BD,(A-B)(D-C)`这3次n/2位乘法即可，其时间复杂度为$O(n^{log3})$，是对直接运算$O(n^2)$的改进。
* **Strassen矩阵乘法**：设AB都是`n*n`的方阵（n偶），则计算A×B时考虑矩阵分块，视其为由`2*2`的子矩阵构成的矩阵，从而有：$\left[\begin{array}{cc} A_{11} & A_{12} \\ A_{21} & A_{22} \end{array}\right]\left[\begin{array}{cc} B_{11} & B_{12} \\ B_{21} & B_{22} \end{array}\right]=\left[\begin{array}{cc} C_{11} & C_{12} \\ C_{21} & C_{22} \end{array}\right]$。由于仍然要执行8次n/2阶方阵乘法，并未减小乘法计算量；故考虑利用如下计算法则，将8次乘法减小到7次乘法，从而复杂度由$O(n^3)$降到$O(n^{log7})$。

| Multiplication | Result  |
| ---------------  | --------------- |
| $M_1=A_{11}(B_{12}-B_{22})$ | $C_{11}=M_5+M_4-M_2+M_6$ |
| $M_2=(A_{11}+A_{12})B_{11}$ | $C_{12}=M_1+M_2$ |
| $M_3=(A_{21}+A_{22})B_{11}$ | $C_{21}=M_3+M_4$ |
| $M_4=A_{22}(B_{21}-B_{11})$ | $C_{22}=M_5+M_1-M_3-M_7$ |
| $M_5=(A_{11}+A_{22})(B_{11}+B_{22})$ |  |
| $M_6=(A_{12}-A_{22})(B_{21}+B_{22})$ |  |
| $M_7=(A_{11}-A_{21})(B_{11}+B_{12})$ |  |

* **快速排序 & 归并排序**：快速排序使左边都不大于基准，右边都不小于基准，再对2侧分别进行快排；归并排序对左右2个子区间进行归并排序，再将2个区间合并。都是利用的 **分而治之** 的思想。详见6.2和6.5。

### 5.5 分治法的递归实现

* **棋盘覆盖**：在一个$2^k×2^k$的棋盘中有且仅有1个特殊位置，要求在其余位置处填上不同编号的L型骨牌。显然将棋盘划分为规格一致的4个子棋盘后，特殊位置比在其中之一处。若特殊位置不在左上子棋盘中则标记该子棋盘的右下角特殊，若不在右上子棋盘中则标记左下角特殊，以此类推；若特殊位置在某子棋盘中则直接递归调用该方法即可。
* **第k小的数**：在`[l,r]`区间内求第k大的数。①利用STL中的nth_element()快速求出；②利用排序算法，在取位置k处的数；③主席树维护（劝退）；④考虑分治，只进行快速排序的第一次遍历，从而出现`[l, i]`和`[i+1, r]`两个区间，满足前者所有数都不大于后者所有数，记`ct = i - l + 1`为左半区间元素个数，则若`k≤ct`则只需在`[l,i]`中找第k小的数，否则秩序在`[i+1,r]`中找第k-ct小的数即可，递归调用自身即可。其时间复杂度O(n)。
* **最近点对**：给定二维平面若干点的坐标，求最近两点之间的距离。可以按x升序再按y升序，将点集按x轴一分为二，分别求出2个子集合的最近点对后取最小值d。然后考虑2点分别在2个点集里的情况，显然二重遍历复杂度过高，一个剪枝思路是：若有该情况的最近点对，则2点到中心点距离都不大于d，继而进行二重遍历。第二个剪枝思路是：选出的这些点按y排序，则在进行第2重遍历时，若2点之间距离大于d则后面的点距离会更大，直接跳出循环即可。
* [分治问题代码实现](https://github.com/KingJoySaiy/Iterator/blob/master/Algorithm/DivideAndConquer.cpp)

## 六、内部排序

### 6.1 基本概念

* **稳定性**：经过排序后，若原序列中相等的记录次序不变，则称该排序算法是 **稳定的**，否则 **不稳定**。
* **内部排序**：待排序记录存放在计算机随机存储器中进行的排序过程；**外部排序**：待排序记录的数量大到内存一次不能容纳全部记录，在排序过程中需要对外村进行访问的排序过程。
* **排序分类**：分为 **插入排序**（直接插,折半插,希尔）、**交换排序**（交换,快排）、**选择排序**（选择,堆排）、**归并排序**、**计数排序**（桶排） 5大类。

### 6.2 插入排序

* **直接插入排序**：将记录插入到已排好序的有序表中，从而不断得到新的、记录数+1的有序表。排序过程进行`n-1`次插入，每次插入需要往前顺序扫描。先将第1个数视为有序的子序列，然后从第2个记录起依次插入，直到整个序列按关键字有序为止。时间复杂度为`O(n^2)`。
* **折半插入排序**：将新记录插入到原有序序列中时，需要找到待插入的位置，此时可以不用顺序查找，而是用 **折半查找**，从而将时间复杂度降到了`O(nlogn)`。
* **希尔排序**：先将整个序列按照 **希尔增量** 分割为若干子序列，分别进行直接插入排序，再不断减小希尔增量到1，从而完成排序操作。设希尔增量为h，则[0, h, 2h...]为一组，[1, h+1, 2h+1...]为一组，以此类推。希尔增量可以有各种取法，但需注意增量序列公因子必须为1（唯一），且最后一个增量为1。复杂度视希尔增量的选择而定。
* [插入排序代码实现](https://github.com/KingJoySaiy/Iterator/tree/master/Data%20Structure/Sort/InsertionSort.h)

### 6.3 交换排序

* **冒泡排序**：不断比较相邻元素，若不有序则交换当前2个元素。进行`n-1`轮冒泡，每次将最小的元素不断交换放到乱序序列的最前端，从而保证前缀总是有序的，最终整个序列有序。复杂度为`O(n^2)`。
* **快速排序**：快速排序是对冒泡排序的改进，每一趟都将待排序的记录分割为2部分，即左半部分都比右半部分小，然后分别对2个子区间进行快速排序，从而使整个序列有序。复杂度为`O(nlogn)`。
* [交换排序代码实现](https://github.com/KingJoySaiy/Iterator/tree/master/Data%20Structure/Sort/SwapSort.h)

### 6.4 选择排序

* **选择排序**：进行`n-1`轮选择，每次选择最小元素放到最前端（与冒泡不同的是，冒泡不断交换相邻元素，而选择是每轮选出最小元素进行1次交换）。复杂度为`O(n^2)`。
* **堆排序**：利用 **最大堆**（树形结构，根一定是最小结点）和 **最小堆**（根一定是最大结点），将待排序的序列放到堆中，再依次取出即可。复杂度为`O(nlogn)`。
* [选择排序代码实现](https://github.com/KingJoySaiy/Iterator/tree/master/Data%20Structure/Sort/SelectionSort.h)

### 6.5 归并排序

* **归并排序**：将待排序的序列分为2个子区间，将子区间排序后将其合并即可。其复杂度为`O(nlogn)`，和 **快排** 与 **堆排** 相比，其最大特点在于 **稳定**，即原序列中相等的元素在排序后保持原本的相对次序不变。
* **求逆序数**：一个序列的逆序数是指每个数之前大于该数的个数之和，在归并排序合并2个升序序列时，设`[left, mid]`区间下标为i，`[mid+1, right]`区间下标为j，则若出现`a[i]>a[j]`则显然`[i,mid]`区间所有数都大于`a[j]`，故答案不断加上`mid-i+1`即可。
* [归并排序代码实现](https://github.com/KingJoySaiy/Iterator/tree/master/Data%20Structure/Sort/MergeSort.h)

### 6.6 计数排序

* **计数排序**：当数据为 **整数** 、范围较小且存在大量重复的记录时，应优先考虑计数排序，其思路是统计每个等于下标i的记录，再按从顺序依次输出相应个数个i即可。
* **桶排序**：当数据为 **整数** 时，将记录划分为k个区间，则x落在第`x/k`个区间内，从而进行计数；再对每一个区间进行使用其他方式进行排序，是一种 **分而治之** 的策略。而计数排序在`桶容量为1下`特殊的桶排序。对于每个桶有 **数组存储** 和 **链式存储** 2种方式，由于一开始每个桶容量未知，故前者可能浪费大量存储空间，而后者在避免了空间问题的同时，动态分配内存也会耗费时间。
* **基数排序**：当数据为 **非负整数** 时，比较数的大小即从最高位到最低位进行比较，一旦某一位开始不同即可判断2数的大小关系。其排序方式分为`LSD(Least significant digital)`和`MSD(Most significant digital)`，前者从个位数开始往左，后者相反。一种`LSD`实现方式为：用`[0...9]`10个桶记录个位数与之对应的记录，再用桶去记录十位数（若相等则按上一位顺序），以此类推直到最高位，从而可以建立有序的基数表。
* [计数排序代码实现](https://github.com/KingJoySaiy/Iterator/tree/master/Data%20Structure/Sort/CountingSort.h)

## 七、动态规划和贪心

### 7.1 DP概述
* **基本思想**：用一个二维的最优决策表来记录所有已解决的子问题的答案，行表示决策的阶段，列表示问题的状态，记录的是问题再当前状态下的最优值。`f[n][m] = max{f(n-1,, m), f[n-1][m-w[n]]+p[n][m]}`。
* **步骤**：①找出 **最优解结构特征** 和性质；② **递归的定义** 最优值；③以自底向上的方式 **计算出最优值**；④根据计算的最优值时的信息，构造最优解。（第4步可省去）
* **基本要素**：①**最优子结构**，即问题的最优解包含了其子问题的最优解；②**重叠子问题**，即若用递归算法自顶向下求解时，每次产生的问题不总是新问题，有些问题被反复计算多次。
* **与分治法的区别**：适合于用动态规划法求解的问题，经分解后得到的子问题往往不是互相独立的（即下一个子阶段的求解是建立在上一个子阶段的解的基础上，进行进一步的求解）。

### 7.2 动态规划问题
* **矩阵连乘**：按顺序给定n个可以合法连乘的矩阵，第i个矩阵为`A[i]`的大小为`a[i-1]×a[i]`，给矩阵序列加括号使之乘法计算量最小。若`i<j`，则在矩阵连乘时必有断点k(`i≤k<j`)，使之分为`A[i:k-1]×A[k:j]`两个子问题，且具有 **最有子结构性质**；问题转化为`dp[i:j]=dp[i:k-1]+dp[k][j]+a[i-1]a[k]a[j]`，且具有递归关系，从而有 **状态转移方程**：$dp[i][j]=\begin{cases} min_{i≤k<j}\{dp[i][k] + dp[k][j] + a[i-1]×a[k]×a[j]\} & i < j \\ 0 & i  == j \end{cases}$。
* **①最长公共子序列**：给定2个序列求其最长公共子序列（可以不连续）。设`dp[i][j]`表示a序列前i个元素和b序列前j个元素的最长公共子序列长度，易知`a[i - 1] == b[j - 1]`时，`dp[i][j] = dp[i - 1][j - 1] + 1`,否则`dp[i][j] = max{dp[i - 1][j], dp[i][j - 1]}`，即为状态转移方程，最优解为`dp[n][m]`。**②最长公共子串**：与上文不同的是，公共子串要求连续。设`dp[i][j]`表示以`a[i]`和`b[j]`结尾的最长公共子串长度，考虑到串的连续要求，$dp[i][j]=\begin{cases} dp[i - 1][j - 1] + 1 & a[i - 1] == b[j - 1] \\ 0 & a[i - 1] != b[j - 1] \end{cases}$。最优解为 `max{dp[i][j]},0≤i≤n,0≤j≤m` 。
* **①最大子段和**：给定可能含负数的序列，求连续子段之和最大值。设`b[i]`表示最后为第i个数的最大子段和，易知 $b[i] = \begin{cases} a[i] & b[i - 1] < 0 \\ d[i - 1] + a[i] & b[i - 1]≥0 \end{cases}$，从而`max{d[i]},0≤i<n`即为所求最优解。**②最大子矩阵和**：给定可能带负数的`n*m`矩阵，求子矩阵中元素之和的最大值。暴力求法`O(n^2m^2)`显然不可取，可以考虑求出矩阵每一列的前缀和，然后枚举从第i行到第j行达到降维的目的，问题转化为已知矩阵i行到j行的列前缀和，求该序列上的最大子段和。求法同上，复杂度为`O(n^2m)`。
* **0-1背包问题**：给定n个分别有重量w和价值v的物品，背包容量为all，求能装入背包的最大价值。设`dp[i][j]`表示前i个物品中选出重量不超过j的物品可能的最大价值，初始状态`dp[0][j] = 0`，则有$dp[i + 1][j] = \begin{cases} dp[i][j] & j < w[i] \\ max\{dp[i][j], dp[i][j - w[i]] + v[i]\} & j ≥ w[i] \end{cases}$，最优解为`dp[n][all]`。
* [动态规划代码实现](https://github.com/KingJoySaiy/Iterator/tree/master/Algorithm/DynamicProgramming.cpp)

### 7.3 贪心概述

* **基本思想**：在每一步选择中都采取当前状态下最优的选择，从而希望导致的结果是最优的。
* **基本要素**：①问题最优解可通过一系列局部最优解选择，即 **贪心选择** 来达到；②贪心算法在 **最优子结构** 中尤为有效，其含义是局部最优解能决定全局最优解。
* **与DP的区别**：虽然二者都要求问题具有 **最优子结构** 性质，但是 **动态规划** 通常以自底向上的方式解决子问题，会保存以前的运算结果，并根据以前的结果对当前状态进行选择，有回退功能；而 **贪心算法** 通常是自顶向下以迭代的方式相机做出贪心选择，每做一次贪心选择就将所求问题简化为规模更小的子问题，没有回退功能。

### 6.4 贪心经典问题
* **部分背包问题**：与上述`0-1背包问题`不同的是，部分背包允许只取物品的一部分（但不能取>1）。贪心策略是按照性价比`v[i]/w[i]`降序排序，当背包容量够时取完整的当前物品，否则取满背包为止。
* **最优装载**：给定n个重量为`w[i]`的物品，要求选择若干物品装入容量为all的船，使物品个数最大。显然按重量升序后从轻的开始选即可。
* **单源最短路**：给定一个带权图`G=(V,E)`（有向无向皆可），求从某一起点x开始到各个节点的最短路径长度。Dijkstra算法给出贪心思路：用bool数组标记答案是否确定（初始状态仅有x确定），每次在未确定答案的节点中选出距离最小的点，并以该点为起点遍历，尝试对其他答案进行 **松弛操作**。
* **最小生成树**：给定连通的无向图，求其连通的子图中权值之和的最小值。**Prim算法**提供的贪心思路是：以任意点作为起始点，不断从未标记的点中选取能到达的权值最小的点，将其标记。**Kruskal算法**提供的贪心思路是：按边的权值升序，依次取最小权值的边，若2点不在同一集合里则将其合并，否则忽略该边。二者的思路大致相同，只是贪心的出发点不同，前者为加点，后者为加边。
* **哈夫曼编码**：为使 **树的带权路径长度** 最小，哈夫曼编码的 **贪心策略** 是：每次合并根节点权值最小的2个子树，二者根节点权值之和作为新树的根节点权值。详见4.3。
* [贪心算法代码实现](https://github.com/KingJoySaiy/Iterator/tree/master/Algorithm/Greedy.cpp)

## 八、回溯法(DFS)

### 8.1	回溯法概述
* **基本思想**：把问题的解空间转化成图或者树的结构表示，然后使用 **深度优先搜索** 策略进行遍历，遍历的过程中记录和寻找所有可行解或者最优解。回溯法的思想与 **图的深度优先搜索** 和 **树的后根遍历** 相一致。本质上是 **暴力搜索**，但和暴力的不同之处在于，在求解过程中能够对不符合要求的结点及时剪枝，并“回溯”回去。
* **剪枝函数**：2种提高回溯法的搜索效率方法：①用 **约束函数** 在扩展结点处减去不满足约束的子树；②用 **限界函数** 减去得不到最优解的子树。二者统称为 **剪枝函数**。
* **递归回溯**：思路简单，容易设计，但效率低。模版如下：
```c++
void backtrack(int id) {
	if (id > n) output(n);	//叶子节点，输出结果，x为可行解
	else {
		for (int i = f(n, id); i <= g(n, id); i++) {	//当前结点的所有子节点
			x[id] = value(i);	//每个子节点值赋给x
			if (constraint(id) && bound(id)) backtrack(id + 1);	//若满足约束条件和限界函数，则递归下一层
		}
	}
}
```
* **迭代/递推回溯**：算法设计相对复杂，但运行效率高。模版如下：
```c++
void iterativeBacktrack() {

	int id = 1;
	while (id > 0) {
		if (f(n, t) > g(n, t)) {	//若不存在子节点，直接返回上一层
			id--;
			continue;
		}
		for (int i = f(n, t); i <= g(n, t); i++) {
			x[id] = value(i);	//每个子节点值赋给x
			if (constraint(id) && bound(id)) {	//满足约束条件和限界函数
				if (solution(id)) output(x);	//得到一个可行解则输出
				else id++;	//没有得到解则继续向下搜索
			}
		}
	}
}
```

### 8.2 回溯法经典问题
* **符号三角形**：一个n行的倒三角形，第i行有`n-i`个元素(`0≤i<n`)，元素限制为0或1。除第一行外，其余每行的元素为上一行相邻2元素的异或，即`a[i][j] = a[i-1][j] ^ a[i-1][j+1]`。求0和1的个数相等的三角形个数。可以dfs暴搜第一行情况，然后判断该情况是否满足条件即可。复杂度为`O(2^n * n^2)`较高，考虑剪枝：若`n(n+1)/2`即总数为个数则必不满足；在逐层递推时，若0或1个数已经大于一般个数时，也必不满足。
* **n皇后**：在n*n矩阵中确定n个皇后的位置，满足同一行列以及正副斜线上只有一个皇后。可以另`a[i] = j`表示第i行上的皇后在第j列，搜索该数组即可，每次判断是否在同一列或斜线上，即`a[k] == a[i] or abs(k - i) == abs(a[k] - a[i])`。
* **0-1背包**：
* **最大团**：
* **图的m着色**:
* [回溯法代码实现](https://github.com/KingJoySaiy/Iterator/tree/master/Algorithm/BackTracking.cpp)


## 九、分支限界法(BFS)

### 9.1 分支限界法概述

### 9.2 分支限界法经典问题
* **单源最短路**：
* **装载问题**：
* **0-1背包**：
* **最大团**：

## 十、概率算法, 近似算法

## 十一、线性规划与网络流
## 一、文件c语言



## 二、线性表, 栈, 队列, 数组

### 2.1 线性表

- 线性表有 **顺序实现** 和 **链式实现**（起始地址*base, 当前长度len，总长度size） ，链式分为 **单链表**（分为带头结点和不带头结点）、**循环单链表**（head->next=null则空表，须有头指针或尾指针，无头结点）、**双向链表**（有头结点）。
- **链表头结点** ：不带头结点是指head是直接指向首结点的指针，即`head->data`为首结点数据；带头结点是指头结点为多余的新结点，其数据域无意义，指针域指向首结点，即`head->next->data`为首结点数据。单链表带头结点的好处是可以在表头插入结点。

### 2.3 栈和队列

- **顺序栈**（起始地址* base，栈顶* top，总长度size）；**链栈**（带头结点的单链表，头插法）。
- **链队列**（结点QNode[data, *next]，队列Queue[QNode front, rear]）；**顺序循环队列**（ * base，front，rear），注意取模，(rear+1)%maxsize==front则满。

### 2.4 数组

- 数组一旦确定了维数和每一维的元素个数，就确定了整个数组元素个数，故只需用顺序实现即可。其顺序存储结构有：以行为主序和以列为主序，在此只讨论以行序为主序。

以二维数组为例，* base为基址， * bounds为每一维元素个数（从1开始），L为每个数据元素所占存储单元，则有 $ (i,j)=base+(bounds_i×i+j)L $ 。例如3 * 4的二维矩阵中(1,2)相对于基址base的偏移量为 $4 *1+2=6$。

- 推广到n维，有$(j_1,j_2...j_n)=a+[\sum_{i=1}^{n-1}(j_i\prod_{k=i+1}^nb_k)]L$ ，可设constants（$c_n=L, c_{i-1}=b_i×c_i$）从而有 $(j_1,j_2...j_n)=a+L\sum_{i=1}^nc_i$ 。从而**（基址 * base, 维数dim, 每一维元素个数 * bounds，各维数+1时相对基址移动距离 * constants）**。

（n维数组实现代码，占坑）

- **矩阵压缩**：对称矩阵、三角矩阵、对角矩阵算一算下标存到顺序表即可；稀疏矩阵用（i, j, data）存到顺序表（truple *base, 行数n, 列数m, 非0元素个数count）中。

## 三、 树, 二叉树, 查找

### 3.1 树和二叉树

- **非空树**：有且仅有1个根结点，其余结点可分为若干个有限集，每个集合本身又是一棵树（称为子树）。**结点的度**：结点有的子结点个数。**叶子 / 终端结点**：度为0的终端结点（**非终端结点 / 分支结点**反之）。**层次**：根为第1层，根的孩子为第2层，以此类推。**深度 / 高度**：树中结点的最大层次（空树层次为0）。**兄弟结点**：有同一个双亲的结点。**堂兄弟结点**：各自双亲在同一层的结点。**祖先**：从该结点到根所经分支上的所有结点（不含本身，**子孙**即子树中所有结点）。**有序树**：树中结点的各个子树从左到右有序的（**无序树**反之）。**森林**：若干棵不相交的树的集合。
- **二叉树**：度不大于2的有序树。**满二叉树**：深度为k（k≥0）且含有 $2^k-1$ 个结点的二叉树。**完全二叉树**：编号1-n按照满二叉树的结点位置，从根结点起，从上往下从左到右编排（满二叉树是完全二叉树）。
- **二叉树分支数 = 结点数 - 1** ； **度为2的结点数=叶子结点数-1**。
- 有n个结点的完全二叉树深度为 $⌊log_2n⌋-1$ 。
- 完全二叉树**顺序存储**：基址 * base，算一算下标存进去。 **链式存储**：（data, 双亲指针 * parent, 左子节点 * lchild, 右子节点*rchild），parent可以去掉。**双亲表示法**：node（data，双亲位置parent），tree（起始地址 * base，根位置root，结点数n）。**孩子表示法**：list（位置id， * next），node（data，孩子链表 list * children），tree（ * base, root, n）。**二叉链表表示法** ：node（data, 第1个子节点 * firstChild，下一个兄弟结点 * nextSibling），即二维的链表，行即为层数，列即为每行兄弟结点序列。

### 3.2 遍历二叉树、树和森林

- **遍历二叉树**：先序遍历（根左右）；中序遍历（左根右）；后序遍历（左右根）。
- **线索二叉树**（data 左指针 * lchild, 右指针 * rchild，左标记ltag，右标记rtag）的构造：左指针优先指向左子树，若该结点无左子树则指向前驱结点（右指针同理）；标记0表示指向左子结点，为1表示指向前驱结点；头结点左指针指向根结点，右指针指向遍历的最后结点；遍历的第一个结点左指针和最后一个结点右指针，都指向指向头结点。

（遍历二叉树，线索化代码，占坑）

* **森林转化为二叉树** ：若森林空，则二叉树空；否则森林的第一棵树的根作为二叉树的根，第一棵树的子森林转化为二叉树根的左子树，森林除第一棵外的的其余树转化为二叉树根的右子树，依次递归。（特别的，当只有一棵树，转化后的二叉树的根没有右子树；**树也是森林**）。
* **二叉树转化为森林** ：若为空二叉树，则森林空；否则二叉树的根作为森林的第一棵树的根，其左子树转化为森林第一棵树的子森林，右子树转化为森林的其余树，依次递归。

（森林与二叉树的转化代码，占坑）

* **树的遍历**：先根遍历；后根遍历。
* **森林的遍历**：先序遍历（访问第一棵树的根、先序遍历第一棵树的子树森林、先序遍历除第一棵树外的森林）；中序遍历（中序遍历第一棵树的子树森林、访问第一棵树的根、中序遍历除第一棵树外的森林）。
* 注意遍历方式的不同：**二叉树（先序、中序、后序）**；**树（先根、后根）**；**森林（先序、中序）**！

### 3.3 Huffman树

* 树中从一个结点到另一个结点之间的分支构成2结点之间的路径，路径上的分支数目称为 **路径长度**。**树的路径长度** 是从树根到每个结点的路径长度之和。
* 树中所有叶子结点的带权路径长度之和，称为 **树的带权路径长度**，记为$WPL=\sum_{k=1}^nw_kl_k$，$w_k$为每个结点的权值，$l_k$为每个结点的路径长度。WPL最小的二叉树称为 **最优二叉树** 或 **哈夫曼树**。
* 









## 四、排序, 递归, 分治





## 五、动态规划, 贪心





## 六、回溯法, 分支限界法





## 七、概率算法, 近似算法





## 八、线性规划, 网络流